package containerWithMostWater

/*

算法说明：

可以用公式 Area = min(a[i],a[j]) * (i-j) 表示盛水面积.求所有Area中的最大值.
为获取Area的最大值,最直观暴力的方式就是二重循环a[i]和a[j],遍历所有Area的可能取值并求出最大值.时间复杂度为O(n^2).

在上述二重循环中,我们会做如下遍历,以覆盖所有情况:
[i,j]=
[0,1],[0,2],[0,3],[0,4],[0,5] .... [0,n]
      [1,2],[1,3],[1,4],[1,5] .... [1,n]
            [2,3],[2,4],[2,5] .... [2,n]
                  [3,4],[3,5] .... [3,n]
                        [4,5] .... [4,n]
                              ....
                                   [n-1,n]

由于 [0,2] 相对于 [0,1] 横向毕竟增大了1, 因此按上述顺序遍历(首首比较)会导致每一次比较都同时受到横向扩张与纵向比较结果(a[i],a[j])的双重影响, 因此导致每一次比较都是有必要的,无法优化.
反之, 首尾比较, 则可以保证横向长度越比越小, 从而在判断下一轮比较是否会产生更大值时, 只需要考虑纵向比较结果(a[i],a[j])即可.
[0,n],[0,n-1],[0,n-2],[0,n-3] .... [0,4],[0,3],[0,2],[0,1]
[1,n],[1,n-1],[1,n-2],[1,n-3] .... [1,4],[1,3],[1,2]
[2,n],[2,n-1],[2,n-2],[2,n-3] .... [2,4],[2,3]
[3,n],[3,n-1],[3,n-2],[3,n-3] .... [3,4]
....
[n-1,n]

不妨假设,
在[0,n]的比较中, a[0]<a[n], 则后续的[0, n],[0, n-5],....,[0, 1]都可以不看.
因为我们在计算Area时是取 min(a[i],a[j]), 因此, a[0] 和 a[n-4],a[n-5] ...,a[1]的比较, 只能使min(a[0],a[j])取到更小值(<=a[0]), 而且横向长度在持续缩小, 因此最后的Area只会越比越小.
相反,如果在[0,n]的比较中, a[0]>a[n],则后续的[1, n],[2, n],....,[n-1, n]都可以不看.
因为min(a[i],a[n])使得其只能取到比a[n]的更小值(<=a[n]),且横向长度在持续缩小.


假设存在以下情况:
a[0]>a[n],a[0]>a[n-1],a[0]>a[n-2],a[0]<a[n-3]

则需要比较的场景如下:
[0,n],[0,n-1],[0,n-2],[0,n-3]
                      [1,n-3] .... [1,4],[1,3],[1,2]
                      [2,n-3] .... [2,4],[2,3]
                      [3,n-3] .... [3,4]
                      [4,n-3] ....
                      ....

再以上假设的基础上, 假设存在如下情况:
a[1]<a[n-3],a[2]<a[n-3],a[3]>a[n-3],

则需要比较的场景如下:
[0,n],[0,n-1],[0,n-2],[0,n-3]
                      [1,n-3]
                      [2,n-3]
                      [3,n-3] [3,n-4] ....
                              [4,n-4] ....
                              [5,n-4] ....
                              ....

可以看出整个比较过程呈现出双指针移动的效果: 两个指针分别从首尾出发, 比较之后一次后, 较小的一方向心移动.

*/


func maxArea(height []int) int {

}
